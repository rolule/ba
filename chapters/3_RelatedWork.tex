\chapter{Related Work}
In diesem Kapitel werde ich verwandte Arbeiten vorstellen.

\section{Literatur}
Serverless ist allgemein ein noch junges Thema, das erst mit der Einführung von AWS Lambda im Jahre 2014 viel Aufmerksamkeit erfuhr. Es gibt bereits einige Studien zu der Performance von Serverless-Anwendungen, jedoch wurde in den meisten Studien nur Micro-Benchmarks betrachtet, d.h Tests, die nur einen Aspekt untersuchen, bspw. die CPU-Floating-Point Performance und keine realistischen Applikationen untersuchen\cite{scheuner_function-as--service_2020}. Vergleiche mit der Performance von Container-Anwendungen sind nur sehr wenige zu finden. 
In "`Serverless computing: Design, implementation, and performance"'\cite{mcgrath_serverless_2017} wurden mehrere Tests zur Performanz von Serverless-Funktionen durchgeführt. Unter anderem wurde ein Nebenläufigkeits-Test (concurrency test) vorgestellt, bei dem eine Funktion, die sofort terminiert, von einer linear ansteigenden Anzahl an Clients so oft wie möglich hintereinander aufgerufen. Gemessen wurde dabei die Anzahl der Antworten pro Sekunde (responses per second). Ziel dieses Tests war, die performante Ausführung einer skalierten Funktion zu messen. Das Ergebnis zeigte unterschiedliches Skalierverhalten für diverse Cloud-Anbieter; bei AWS Lambda wurde jedoch ein weitestgehend linearer Anstieg festgestellt. 
Des Weiteren werden für zukünftige Forschung noch andere die Performanz von Serverless-Funktionen beeinflussende Aspekte genannt, wie die Ausführung mehrerer Funktionen anstatt nur einer einzigen (single function execution), die Code-Größe einer Serverless-Funktion und unterschiedliche CPU-Allokation (in der Studie wurde lediglich 512MB RAM verwendet).

Das Paper "`Serverless computing: Design, implementation, and performance"'\cite{hendrickson_serverless_2017} vergleicht die Performance von AWS Lambda mit der eines in AWS Beanstalk laufendem Docker-Containers. Dazu sendeten die Forscher jeweils 100 RPC-Requests an beide Services, wobei jeder Service eine Laufzeit von 200ms beanspruchte. Die Durchführung des Tests ergab, dass die Antwortzeit bei Lambda mit einem Medianwert von 1,6 Sekunden deutlich vor der von Beanstalk mit bis zu 20 Sekunden liegt. Als Grund dafür wird angeführt, dass Lambda innerhalb von einigen Millisekunden 100 Instanzen auf die der Last verteilt wurde, während bei Beanstalk alle Anfragen von einer einzigen Instanz bearbeitet wurde, obwohl alle Einstellungen getroffen wurden, damit Beanstalk so schnell wie möglich hochskalieren kann. Hier zeigen sich deutlich die automatischen Skalierungsvorteile einer FaaS Applikation. Während es bei Beanstalk 20 verschiedene Einstellungsmöglichkeiten gäbe, übernimmt Lambda dies vollkommen automatisch.
Allerdings wird auch deutlich, dass die Latenz von Lambda Funktionen bei einer normalen Last deutlich über der eines Containers liegt. Mit der gleichen Testumgebung und unter leichter Last, performe Lambda 10 mal schlechter als Beanstalk. Da dieser Test im Jahre 2017 durchgeführt wurde, stimmen diese Ergebnisse aber vermutlich nicht mit den in der Zwischenzeit an Lambda vorgenommenen Performance-Verbesserungen überein.

Das Paper "`Infrastructure cost comparison of running web applications in the cloud using aws lambda and monolithic and microservice architectures"'\cite{villamizar_infrastructure_2016} vergleicht die Performance und infrastrukturellen Kosten einer auf verschiedene Arten deployten Applikation. Die Anwendung wurde als Monolith und als Microservices mit und ohne AWS Lambda betrieben. Dabei zeigte sich,  dass die Kosten für den Betrieb bei einer auf Lambda basierten Microservices Architektur deutlich (mehr als 70 Prozent) geringer ausfallen können, als bei einem Monolith oder wenn die Microservices von den Entwicklern selbst gemanaged werden. Ebenfalls wurde die Performance der verschiedenen Ansätze mittels der Metrik der durchschnittlichen Antwortzeit (average response time - ART) verglichen. Es wurde deutlich, dass Lambda in unterschiedlichen Test-Szenarien nahezu die gleich ART beibehält, was auf dessen Skalierungsmöglichkeiten zurückgeführt wurde. Des Weiteren performte Lambda teilweise besser als die monolithische Architektur und deutlich besser als die selbst-gemanagten Microservices.
